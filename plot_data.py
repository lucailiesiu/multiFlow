from numpy import *
seterr(all='ignore') # Sometimes it has weird value potentials
import sys
sys.path.append("/u/liliesiu/pp")

import os
import copy
import pylab as p
import math
import mpl_toolkits.mplot3d.axes3d as p3
from matplotlib.backends.backend_pdf import PdfPages

class wmap_data:
    datar = open('wmap/atens','r')
    datan = open('wmap/ns002','r')
    datarun = open('wmap/nrun','r')
    dtype = [('r', float),('n',float),('run',float)]
    values = []
    ind = 0
    for line in datar:
        (index,value)=line.split()
        values.append((float(value), 0.0, 0.0))
    data = array(values, dtype = dtype)
    for line in datan:
        (index,value)=line.split()
        data[ind][1] = float(value)
        ind += 1 
    ind = 0
    for line in datarun:
        (index,value)=line.split()
        data[ind][2] = float(value)
        ind += 1
    datar.close()
    datan.close()
    datarun.close()
    data = sort(data,order = 'n')
    (r, n, run) = ([], [], [])
    for i in arange(len(data)):
        r.append(data[i][0])
        n.append(data[i][1])
        run.append(data[i][2])

def save_data(results, observable_results):
    datafile = open('parameters_results.out', 'w')
    print len(results)
    print len(observable_results)
    for i in arange(1, len(results)):
        print >>datafile,results[i]
        print >>datafile, observable_results[i]
    datafile.close()
    datafile = open('statistic_results.out','w')
    n_late_time_1 = 0
    n_nontrivial = 0
    n_late_time_2 = 0
    n_late_time_3 = 0
    n_insuf = 0
    n_nonid = 0
    for i in arange(len(observable_results)):
        if(observable_results[i][4] == 1):
            if(observable_results[i][0] > 1.3): n_late_time_1 += 1
            if(observable_results[i][0] < 1.3 and observable_results[i][2] > 0.7): n_late_time_2 += 1
            if(observable_results[i][0] < 0.7): n_late_time_3 +=1
        if(observable_results[i][4] == 2): n_insuf += 1
        if(observable_results[i][4] == 3): n_nontrivial += 1
        if(observable_results[i][4] == 4): n_nonid += 1
    print >>datafile,'Late-time attractor, n > 1.3: ', n_late_time_1
    print >>datafile,'Late-time attractor, 0.7 < n < 1.3: ', n_late_time_2
    print >>datafile,'Late-time attractor, n < 0.7: ', n_late_time_3
    print >>datafile,'Insufficient inflation: ', n_insuf
    print >>datafile,'Nontrivial point: ', n_nontrivial
    print >>datafile,'No asymptotic behavior: ', n_nonid

def plot_nrrun(r, n, run):
    fig = p.figure()
    ax = fig.gca(projection = '3d')
    ax.plot(n, r, run,',')  
    ax.set_xlabel('n')
    ax.set_ylabel('r')
    ax.set_zlabel('d n / d ln k')
    ax.set_xlim(0, 5)
    ax.set_ylim(0, 1)
    ax.set_zlim(-1, 1)
    p.title('Possible outcome for random potential inflation parameters (n vs. r vs. d n / d ln k)')
    # p.show()
    p.savefig(pag, format = 'pdf')
  
def plot_nr(n,r):
    fig = p.figure()
    wmap = p.plot(wmap_data.n,wmap_data.r,'r', label = 'WMAP Limits') 
    data_points = p.plot(n, r, ',', label = 'Generated data points')
    p.legend()#[wmap, data_points], ["WMAP inflation limits", "Generated data points"])
    p.xlabel('n')
    p.ylabel('r')
    p.xlim(0.7, 1.3)
    p.ylim(0, 0.5)
    p.title('Spectral index n vs. tensor ration r generated by APS')
    fig.savefig("plot_data/nr"+str(file_number), format = 'png')  
 
def plot_nrun(n, run):
    fig = p.figure()
    wmap = p.plot(wmap_data.n,wmap_data.run,'r',label = 'WMAP Limits')
    data_points = p.plot(n, run,',', label = 'Generated data points')
    p.legend()
    p.xlim(0, 5)
    p.ylim(-1, 1)
    p.xlabel('n')
    p.ylabel('d n / d ln k')
    p.title('Spectral index n vs. run factor d n / d ln k generated by APS')
    fig.savefig("plot_data/nrun"+str(file_number), format = 'png') 
 
def plot_rrun(r, run):
    fig = p.figure()
    p.plot(r, run,',')
    p.xlim(0, 5)
    p.ylim(-1, 1)
    p.xlabel('r')
    p.ylabel('d n / d ln k')
    p.title('Tensor factor r vs. run factor d n / d ln k generated by APS')
    fig.savefig("plot_data/rrun"+str(file_number), format = 'png') 
 

def plot_fNLn(n, f_NL):
    fig = p.figure()
    for i in range(len(n)):
        try:
            _n = []
            _f_NL = []
            _n.append(n[i])
            _f_NL.append(f_NL[i])
            p.plot(_n, _f_NL,'bo')
        except:
            print "Overflow error"
    p.xlim(-5, 10)
    p.xlabel('n')
    p.ylabel(r'$f_{NL}$')
    p.title(r'Spectral index n vs.non-gaussianity factor $f_{NL}$')
    fig.savefig("plot_data/nfNL"+str(file_number), format = 'png') 
    
def plot_fNLr(r, f_NL):
    fig = p.figure()
    for i in range(len(r)):
        try:
            _r = []
            _f_NL = []
            _r.append(r[i])
            _f_NL.append(f_NL[i])
            p.plot(_r, _f_NL,'bo')
        except:
            print "Overflow error"
        p.plot(r, f_NL,'bo')
    p.xlim(-5, 10)
    p.xlabel('r')
    p.ylabel(r'$f_{NL}$')
    p.title(r'Tensor spectral index  n vs.non-gaussianity factor $f_{NL}$')
    fig.savefig("plot_data/rfNL"+str(file_number), format = 'png') 

# def plot_nr_limits(): To be done

def plot_parameter_traj(M, results, fields):
    fig = p.figure()
    epsilon = []
    nu = []
    eps1 = []
    eps2 = []
    eps3 = []
    if (M == 1):
        epsilon = []
        nu = []
        for i in arange(len(fields)): 
            epsilon.append(results[i][0][0] ** 2);
            nu.append(results[i][1][0]);  
        ax = fig.gca()
        ax.plot(epsilon, nu)
        ax.set_xlabel(r'$\epsilon$')
        ax.set_ylabel(r'$\eta$')
        p.title(r'Initial conditions: $\epsilon $=' +str(round(epsilon[0], 3))+ ' and $\eta $= '+ str(round(nu[0], 3)))
        p.savefig(pr, format = 'pdf')
    if (M == 2):
        eps1 = []
        eps2 = []
        for i in arange(len(results)): 
            eps1.append(results[i][0][0]);
            eps2.append(results[i][0][1]);         
        ax = fig.gca()
        ax.plot(eps1, eps2)
        ax.set_xlabel(r'$\epsilon_1$')
        ax.set_ylabel(r'$\epsilon_2$')
        p.title(r'Initial conditions: $\epsilon_1 $=' +str(round(eps1[0], 3))+ ' and $\epsilon_2 $= '+ str(round(eps2[0], 3)))
        p.savefig(pr, format = 'pdf')
    if (M == 3):
        eps1 = []
        eps2 = []
        eps3 = []
        for i in arange(len(results)): 
            eps1.append(results[i][0][0]);
            eps2.append(results[i][0][1]);         
            eps3.append(results[i][0][2]);
        ax = fig.gca(projection = '3d')
        ax.plot(eps1, eps2, eps3, 'bo')
        ax.set_xlabel(r'$\epsilon_1$')
        ax.set_ylabel(r'$\epsilon_2$')
        ax.set_zlabel(r'$\epsilon_3$')
        p.title(r'Initial conditions: $\epsilon_1 $=' +str(round(eps1[0], 3))+ ' and $\epsilon_2 $= '+ str(round(eps2[0], 3)) + ' and $\epsilon_3 $= '+ str(round(eps3[0], 3)) )
        p.savefig(pr, format = 'pdf')
 

        
def plot_potential(M, fields, results):
    fig = p.figure();
    dN = 0.001
    V = []
    N = []
    tau = []
    phi1 = []
    phi2 = []
    for i in arange(len(fields)):
        epsilon = 0
        for j in arange(M):
            epsilon += results[i][0][j]**2
        V.append((fields[i][M])**2 * (1 - (epsilon/3.0)))
        N.append(0.001 * i)
        tau.append(fields[i][M+1])
        phi1.append(fields[i][0])
        phi2.append(fields[i][1])
    p.legend(loc = 4, markerscale = 0.5)
    p.title("Inflationary potential vs number of e-folds")
    p.xlabel('N')
    ax = fig.gca()
    ax.plot(N, V)
    p.ylabel('V/$V_{0}$')
    p.savefig(potent, format = 'pdf')
    p.title("Inflationary potential vs number of e-folds")

    fig = p.figure()
    p.xlabel('$\tau$')
    ax = fig.gca()
    ax.plot(tau, V)
    p.ylabel('V/$V_{0}$')
    p.savefig(potent, format = 'pdf')
    if (M == 2): 
        fig = p.figure()
        ax = fig.gca(projection = '3d')
        ax.plot(phi1, phi2, V)
        ax.set_xlabel('$\phi_1$')
        ax.set_ylabel('$\phi_2$')
        ax.set_zlabel('V')
        p.savefig(potent, format = 'pdf')

       
                                                 
    
def plot_coupling(results, observable_results):
    couple_good = []
    couple_bad = []
    eps1_good = []
    eps1_bad = []
    eps2_good = []
    eps2_bad = []
    for i in arange(len(results)):
        if(observable_results[i][4] == 2 or observable_results[i][4] == 4):
            couple_bad.append(results[i][1][1] + results[i][1][2] + 4 * results[i][0][1]* results[i][0][0])
            eps1_bad.append(results[i][0][0])
            eps2_bad.append(results[i][0][1])
        if(observable_results[i][4] == 1 or observable_results[i][4] == 3):
            couple_good.append(results[i][1][1] + results[i][1][2] + 4 * results[i][0][1]* results[i][0][0])
            eps1_good.append(results[i][0][0])
            eps2_good.append(results[i][0][1])
    fig = p.figure()
    ax = fig.gca(projection = '3d')
    ax.scatter(eps1_good,eps2_good, couple_good, s = 1, c='b', alpha = 0.1, label = '"Good" Inflation Points')
    ax.scatter(eps1_bad,eps2_bad, couple_bad,s = 1, c = 'r', alpha = 0.02, label = '"Bad" Inflation Points')
    ax.set_xlabel(r'$\epsilon_1$')
    ax.set_ylabel(r'$\epsilon_2$')
    ax.set_zlabel(r'$\frac{\partial^2 V}{\partial \phi_1 \partial \phi_2}$')
    ax.set_xlim(0, 0.8)
    ax.set_ylim(0, 0.8)
    ax.set_zlim(-1, 1)
    p.title('Generated solutions in the coupling space')
    p.savefig(pag, format = 'pdf')
    fig.savefig("plot_data/coupling"+str(file_number), format = 'png')
    #fig.show()
    #raw_input()
    fig = p.figure()
    n, bins, patches = p.hist(couple_good, 100, facecolor = 'g', alpha = 0.8)
    p.grid(True)
    p.title('Coupling Histogram - Good solutions in the coupling space')
    p.xlabel(r'$\frac{1}{4\pi G} \frac{\partial^2 V}{\partial \phi_1 \partial \phi_2}$')
    p.ylabel('Number of points')
    fig.savefig("plot_data/coupling_hist"+str(file_number), format = 'png')
    fig = p.figure()
    hist_good, bin_edges = histogram(couple_good, bins = arange(-1.0, 3.5, 0.05))
    hist_bad, bin_edges = histogram(couple_bad, bins = arange(-1.0, 3.5, 0.05))
    relative = []
    for i in arange(len(hist_good)):
        if((hist_good[i] + hist_bad[i]) != 0):
            relative.append(((1.0) * hist_good[i])/(1.0* (hist_good[i] + hist_bad[i])))
        else:
            relative.append(0)
    p.plot(arange(-1.0, 3.45, 0.05), relative)
    p.title('Coupling Histogram - Number of good solutions relative to total number in the coupling space')
    p.xlabel(r'$\frac{1}{4\pi G} \frac{\partial^2 V}{\partial \phi_1 \partial \phi_2}$')
    p.ylabel('Relative number of points')
    fig.savefig("plot_data/coupling_relative"+str(file_number), format = 'png')
   
    
def run_simulation(param):
    return aps.APS(param[0], param[1], param[2], param[3])


file_number = 0
while(os.path.isfile('data/evolution'+ str(file_number) +'.out')):
    datafile = open('data/evolution'+ str(file_number) +'.out', 'r')
    print "Plotting", file_number,"..."
    file_number += 1
    print "Reading file"
    fields = []
    results = []
    observable_results = []
    line_nr = 0;
    for line in datafile:
        if (line_nr == 0):
            observable_results.append(eval(line))
        else: 
            if(line_nr % 2 == 1):
                results.append(eval(line))
            if(line_nr % 2 == 0):
                fields.append(eval(line))
        line_nr += 1
    M = len(results[0][0])    
    print M
    pr = PdfPages('plot_data/parameter_traj_' + str(file_number)+ '.pdf')
    potent = PdfPages('plot_data/potential_func_'+str(file_number)+'.pdf')
    print "Plotting parameter trajectory:"

    plot_parameter_traj(M, results,fields)
    pr.close()
   
    print "Plotting potential"
    plot_potential(M, fields, results)
    potent.close()
 
